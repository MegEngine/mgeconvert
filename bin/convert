#!/usr/bin/python3

import argparse
from typing import List, Union

import mgeconvert


def get_targets(module):
    targets = []
    for attr in dir(module):
        if attr.startswith("mge_to") or attr.startswith("tracedmodule_to"):
            targets.append(attr)
    return targets


def init(subparsers):
    targets = get_targets(mgeconvert)

    for target in targets:
        if "caffe" in target:
            def to_caffe(args):
                outspec = None
                if args.end_point is not None:
                    outspec = args.end_point.split(";")
                converter_map = {
                    "tracedmodule_to_caffe": mgeconvert.tracedmodule_to_caffe,
                    "mge_to_caffe": mgeconvert.mge_to_caffe,
                }
                converter_map[target](
                    args.input, prototxt=args.prototxt, caffemodel=args.caffemodel, outspec=outspec
                )
            def caffe_parser(subparsers):
                p = subparsers.add_parser(target)
                p.set_defaults(func=to_caffe)
                p.add_argument(
                    "-i", "--input", required=True, type=str, help="Input megengine dump model file"
                )
                p.add_argument(
                    "-c", "--prototxt", required=True, type=str, help="Output caffe .prototxt file"
                )
                p.add_argument(
                    "-b",
                    "--caffemodel",
                    required=True,
                    type=str,
                    help="Output caffe .caffemodel file",
                )

                p.add_argument(
                    "--end_point",
                    default=None,
                    type=str,
                    help="end_point is used to specify which part of the mge model should be converted",
                )
            caffe_parser(subparsers)
        if "onnx" in target:
            def to_onnx(args):
                outspec = None
                if args.end_point is not None:
                    outspec = args.end_point.split(";")
                converter_map = {
                    "tracedmodule_to_onnx": mgeconvert.tracedmodule_to_onnx,
                    "mge_to_onnx": mgeconvert.mge_to_onnx,
                }
                converter_map[target](
                    args.input,
                    args.output,
                    graph_name=args.graph,
                    opset=args.opset,
                    outspec=outspec,
                )
            def onnx_parser(subparsers):
                p = subparsers.add_parser("onnx")
                p.set_defaults(func=to_onnx)
                p.add_argument(
                    "-i", "--input", required=True, type=str, help="Input megengine dump model file"
                )
                p.add_argument(
                    "-o", "--output", required=True, type=str, help="Output onnx .onnx file"
                )
                p.add_argument("--opset", default=8, type=int, help="Onnx opset version")
                p.add_argument("--graph_name", default="graph", type=str, help="Onnx graph name")
                p.add_argument(
                    "--end_point",
                    default=None,
                    type=str,
                    help="end_point is used to specify which part of the mge model should be converted",
                )
            onnx_parser(subparsers)
        if "tflite" in target:
            def to_tflite(args):
                if "tracedmodule" in target:
                    mgeconvert.tracedmodule_to_tflite(
                        mge_fpath=args.input,
                        output=args.output,
                        input_data_type = args.input_data_type,
                        input_scales = args.input_scales,
                        input_zero_points = args.input_zero_points,
                        require_quantize=args.require_quantize,
                        param_fake_quant=args.param_fake_quant,
                        quantize_file_path=args.quantize_file_path,
                        graph_name=args.graph_name,
                        mtk=args.mtk,
                        outspec=args.outspec,
                    )
                else:
                    mgeconvert.mge_to_tflite(
                        mge_fpath=args.input,
                        output=args.output,
                        graph_name=args.graph_name,
                        mtk=args.mtk,
                        outspec=args.outspec,
                    )
            def tflite_parser(subparsers):
                p = subparsers.add_parser(target)
                p.set_defaults(func=to_tflite)
                p.add_argument(
                    "-i", "--input", required=True, type=str, help="megengine dumped model file"
                )
                p.add_argument(
                    "-o", "--output", required=True, type=str, help="converted TFLite model file"
                )
                if "tracedmodule" in target:
                    p.add_argument(
                        "--input_data_type",
                        default=None,
                        type=str,
                        help="the dtype of input data used for quantize model input",
                    )
                    p.add_argument(
                        "--input_scales",
                        default=None,
                        type=Union[float, List[float]],
                        help="the scale of input data used for quantize model input",
                    )
                    p.add_argument(
                        "--input_zero_points",
                        default=None,
                        type=Union[int, List[int]],
                        help="the zero point of input data used for quantize model input",
                    )
                    p.add_argument(
                        "--require_quantize",
                        action="store_false",
                        help="whether to do quantize if the model has quantization parameters",
                    )
                    p.add_argument(
                        "--param_fake_quant",
                        action="store_false",
                        help="whether to do fake quantize for parameters if the model has quantization parameters",
                    )
                    p.add_argument(
                        "--quantize_file_path",
                        default="quant_params.json",
                        type=str,
                        help="",
                    )
                p.add_argument(
                    "--graph-name",
                    default="graph0",
                    type=str,
                    help="default subgraph name in TFLite model",
                )
                p.add_argument(
                    "--mtk", action="store_true", help="If target flatform is MTK(P70, P80)"
                )
                p.add_argument(
                    "--outspec",
                    default=None,
                    type=list,
                    help="the names of end points of the model",
                )

            tflite_parser(subparsers)


def main():
    targets = get_targets(mgeconvert)
    msg = targets[0] if len(targets) == 1 else "{" + ", ".join(targets) + "}"
    parser = argparse.ArgumentParser(
        description="use \"convert %s -h\" for more details" % msg
    )
    subparsers = parser.add_subparsers()
    init(subparsers)
    args = parser.parse_args()
    if hasattr(args, "func"):
        args.func(args)
    else:
        print("[error] please point out which framework you want to convert")
        print("use \"convert -h\" for help")


if __name__ == "__main__":
    main()
